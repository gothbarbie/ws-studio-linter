const allMatches = require( './util/allMatches.js' );
const parseJS = require( 'acorn' ).parse;
const Pos = require( './position.js' );

module.exports = validateJS;

function validateJS( text, start, errors ) {
	var ast;

	start = start || Pos.initial();
	errors = errors || [];

	const comments = [];

	try {
		ast = parseJS( text, { locations: true, onComment: comments } );
	} catch ( e ) {
		var errorPos = Pos.add( start, fixPos( e.loc, e.pos ) );

		errors.push({
			start: errorPos,
			end: Pos.move( errorPos, e.raisedAt - e.pos ),
			message: e.name + ': ' + e.message
		});

		return errors;
	}

	comments.filter( c => c.type === 'Line' ).forEach( comment => {
		errors.push({
			start: Pos.add( start, fixPos( comment.loc.start, comment.start ) ),
			end: Pos.add( start, fixPos( comment.loc.end, comment.end ) ),
			message: `line comments aren't allowed`
		});
	});

	ast.body.forEach( topLevel => validateTopLevelJS( topLevel, start, errors ) );

	return errors;
}

function validateTopLevelJS ( node, start, errors ) {
	const declaration = decl => {
		if ( decl.id.name.indexOf( 'WS_DYN_INS_RAND' ) === -1 ) {
			errors.push({
				start: Pos.add( start, fixPos( decl.id.loc.start, decl.id.start ) ),
				end: Pos.add( start, fixPos( decl.id.loc.end, decl.id.end ) ),
				message: `Global variable '${ decl.id.name }' is missing WS_DYN_INS_RAND`
			});
		}
	};

	switch ( node.type ) {
		case 'VariableDeclaration':
			node.declarations.forEach( declaration );
			break;

		case 'FunctionDeclaration':
			declaration( node );
			break;
	}
}

function fixPos( pos, index ) {
	return {
		index: pos.index || index,
		line: pos.line - 1,
		column: pos.column
	};
}
