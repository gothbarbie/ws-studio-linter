const parseCSS = require( 'postcss' ).parse;
const Pos = require( './position.js' );

const postcssFix = { line: -1, column: -1 };

module.exports = validateCSS;

function validateCSS( text, start, errors ) {
	var root;

	start = start || Pos.initial();
	errors = errors || [];

	try {
		root = parseCSS( text );
	} catch ( e ) {
		// TODO: postcss errors don't have an `index` property.
		var errorPos = Pos.add( start, fixPos( e ) );

		errors.push({
			start: errorPos,
			end: Pos.move( errorPos, ' ' /* make the error underline something */ ),
			message: e.name + ': ' + e.message
		});

		return errors;
	}

	root.walkAtRules( node => {
		if ( node.params.indexOf( 'WS_DYN_INS_RAND' ) === -1 ) {
			var ruleStart = Pos.move( Pos.add( start, fixPos( node.source.start ) ), '@' + node.name + node.raws.between );

			errors.push({
				start: ruleStart,
				end: Pos.move( ruleStart, node.params ),
				message: `CSS @rule parameter '${ node.params }' is missing WS_DYN_INS_RAND`
			});
		}
	});

	root.walkRules( node => {
		if ( node.selector.indexOf( 'WS_DYN_INS_RAND' ) === -1 ) {
			var selectorStart = Pos.add( start, fixPos( node.source.start ) );

			errors.push({
				start: selectorStart,
				end: Pos.move( selectorStart, node.selector ),
				message: `CSS selector '${ node.selector }' is missing WS_DYN_INS_RAND`
			});
		}
	});

	return errors;
}

function fixPos( pos ) {
	return {
		index: 0,
		line: pos.line - 1,
		column: pos.column - 1
	};
}
